// Shader is looseley based on the ray tracing coding session by Inigo Quilez (www.iquilezles.org)
// Based on Sascha Willems example: https://github.com/SaschaWillems/Vulkan/tree/master/data/shaders/raytracing

#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

#define PI 3.1415926535897932384626422832795028841971
#define TWO_PI 6.2831853071795864769252867665590057683943
#define SQRT_OF_ONE_THIRD 0.5773502691896257645091487805019574556476
#define EPSILON 0.0001
#define MAXLEN 10000.0
#define TRACEDEPTH 2
#define GROUND_MESH_IDX 2

// ==================================
// STRUCT DEFINITIONS
// ==================================

struct PointLight {
	vec4 position;
	vec3 color;
	float radius;
};

struct DirectionalLight {
	vec4 position;
	vec3 color;
	vec3 direction;
};

struct Material
{
	vec4 diffuse;
	vec4 ambient;
	vec4 emission;
	vec4 specular;
	float shininess;
	float refracti;
};

struct Triangle
{
	int materialId;

	vec3 vert0;
	vec3 vert1;
	vec3 vert2;

	vec3 norm0;
	vec3 norm1;
	vec3 norm2;
};

struct Sphere
{
	vec3 position;
	float radius;
};

struct BVHNodePacked
{
	//int id;
	int parent;
	int geomId;
	int nearId;

	int farId;
	vec4 bounds[2];
};

struct Ray
{
	vec3 origin;
	vec3 direction;
    
    // The following variables are pre-computed for faster Ray-AABB intersection tests.
    vec3 inv_direction;
    int sign[3];
};

struct PathSegment {
	Ray ray;
	vec3 color;
	int remainingBounces;
	int objectId;
	int bounces;
};

struct Intersection {
	vec3 hitNormal;
	float t;
	vec3 hitPoint;
	int materialId;
	int objectID;
};

float roughness = 1.0;
float metallic = 0.0;

// ==================================
// BINDINGS
// ==================================

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0) uniform sampler2D positionsImage;
layout (binding = 1) uniform sampler2D normalsImage;
layout (binding = 2, rgba8) uniform writeonly image2D resultImage;

layout (std140, binding = 3) buffer TriangleIndices
{
	ivec4 indicesAndMaterialID[ ];
};

layout (std140, binding = 4) buffer TrianglePositions
{
	vec4 positions[ ];
};

layout (std140, binding = 5) buffer TriangleNormals
{
	vec4 normals[ ];
};

layout (std140, binding = 6) uniform UBO 
{
	vec4 cameraPosition;
	PointLight lights[6];
	int lightCount;
	int materialCount;

	// Toggle flags 
	bool isBVH;
	bool isShadows;
	bool isTransparency;
	bool isReflection;
	bool isColorByRayBounces;
} ubo;


layout (std140, binding = 7) uniform Materials
{
	Material materials[10];
};

layout (std140, binding = 8) buffer BVHNodes
{
    BVHNodePacked bvhNodes[ ];
};

layout (binding = 9) uniform sampler2D albedo;

layout (std140, binding = 10) buffer Spheres
{
	Sphere spheres[ ];
};

layout (binding = 11) uniform samplerCube radianceMap;
layout (binding = 12) uniform samplerCube irradianceMap;

// ==================================
// UTILITIES
// ==================================

float rand(vec2 co){
	// From StackOverflow http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 getPointOnRay(Ray r, float t) {
    return r.origin + (t - .0001f) * normalize(r.direction);
}

// ==================================
// TRIANGLES
// ==================================

void buildTriangle(int i, inout Triangle tri) {
	
	tri.materialId = indicesAndMaterialID[i].w;
	tri.vert0 = vec3(positions[indicesAndMaterialID[i].x]);
	tri.vert1 = vec3(positions[indicesAndMaterialID[i].y]);
	tri.vert2 = vec3(positions[indicesAndMaterialID[i].z]);
	tri.norm0 = vec3(normals[indicesAndMaterialID[i].x]);
	tri.norm1 = vec3(normals[indicesAndMaterialID[i].y]);
	tri.norm2 = vec3(normals[indicesAndMaterialID[i].z]);
}

float triangleIntersect(
	in Triangle tri, 
	in Ray r,
	out vec3 normal,
	out vec3 hitPoint
	) 
{
	// Compute fast intersection using Muller and Trumbore, this skips computing the plane's equation.
	// See https://www.cs.virginia.edu/~gfx/Courses/2003/ImageSynthesis/papers/Acceleration/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf

	float t = -1.0;
	
	// Find the edges that share vertice 0
	vec3 edge1 = tri.vert1 - tri.vert0;
	vec3 edge2 = tri.vert2 - tri.vert0;

	// Being computing determinante. Store pvec for recomputation
	vec3 pvec = cross(r.direction, edge2);
	// If determinant is 0, ray lies in plane of triangle
	float det = dot(pvec, edge1);
	if (abs(det) < EPSILON) {
		return -1;
	}
	float inv_det = 1.0 / det;
	vec3 tvec = r.origin - tri.vert0;

	// u, v are the barycentric coordinates of the intersection point in the triangle
	// t is the distance between the ray's origin and the point of intersection
	float u, v;

	// Compute u
	u = dot(pvec, tvec) * inv_det;
	if (u < 0.0 || u > 1.0) {
		return -1;
	}

	// Compute v
	vec3 qvec = cross(tvec, edge1);
	v = dot(r.direction, qvec) * inv_det;
	if (v < 0.0 || (u + v) > 1.0) {
		return -1;
	}

	// Compute t
	t = dot(edge2, qvec) * inv_det;

	hitPoint = getPointOnRay(r, t);
	normal = normalize(tri.norm0 * (1 - u - v) + tri.norm1 * u + tri.norm2 * v);

	return t;
}

// ==================================
// SPHERES
// ==================================

float sphereIntersect(in Ray ray, in int sphereIdx)
{
    vec3 spherePos  = spheres[sphereIdx].position;
    float sphereRad = spheres[sphereIdx].radius;
    
	vec3 oc = ray.origin - spherePos;
	float b = 2.0 * dot(oc, ray.direction);
	float c = dot(oc, oc) - sphereRad * sphereRad;
	float h = b*b - 4.0*c;
	if (h < 0.0) 
	{
		return -1.0;
	}
	float t = (-b - sqrt(h)) / 2.0;

	return t;
}


// ==================================
// AABB
// ==================================

float aabbIntersect(in Ray r, in int node)
{
	// From Scratch a pixel https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-box-intersection
	BVHNodePacked aabb = bvhNodes[node];
    float tmin  = (aabb.bounds[r.sign[0]].x      - r.origin.x) * r.inv_direction.x;
    float tmax  = (aabb.bounds[1-r.sign[0]].x    - r.origin.x) * r.inv_direction.x;
    float tymin = (aabb.bounds[r.sign[1]].y      - r.origin.y) * r.inv_direction.y;
    float tymax = (aabb.bounds[1-r.sign[1]].y    - r.origin.y) * r.inv_direction.y;
    
    if ( (tmin > tymax) || (tymin > tmax) ) {
        return -1;
	}
    if (tymin > tmin)
        tmin = tymin;
    if (tymax < tmax)
        tmax = tymax;
        
    float tzmin = (aabb.bounds[r.sign[2]].z     - r.origin.z) * r.inv_direction.z;
    float tzmax = (aabb.bounds[1-r.sign[2]].z   - r.origin.z) * r.inv_direction.z;
    
    if ( (tmin > tzmax) || (tzmin > tmax) )
        return -1;
   if (tzmin > tmin)
        tmin = tzmin;
    if (tzmax < tmax)
        tmax = tzmax;
        
    if ( (tmin < MAXLEN) ) {//&& (tmax > EPSILON) ) {
        return 1.0f;
	}
}

// ==================================
// BVH TRAVERSAL
// ==================================

#define FROM_PARENT		0
#define FROM_CHILD		1
#define FROM_SIBLING	2

int getParent(
	in int node
	)
{
	return bvhNodes[node].parent;
}

int getNearChild(
	in int node
	)
{
	return int(bvhNodes[node].nearId);
}

int getFarChild(
	in int node
	)
{
	return int(bvhNodes[node].farId);
}

int getFarSibling(
	in int node
	)
{
	int parent = bvhNodes[node].parent;
	return bvhNodes[parent].farId;
}

int getNearSibling(
	in int node
	)
{
	int parent = bvhNodes[node].parent;
	return bvhNodes[parent].nearId;
}

Intersection calcShadowBVH(
	in Ray ray,
	int node
)
{
	int current = node;
	int nearChild;
	int farChild;
	int state = FROM_PARENT;
	int root = node;
	float t = 0;
	vec3 tmp_normal;
	vec3 tmp_hitPoint;
	float tMin = MAXLEN;

	Intersection isx;
	isx.t = -1;

	bool isIterating = true;
	while(isIterating) {
		nearChild = getNearChild(current);
		farChild = getFarChild(current);

		switch(state) {

			// 1. From child
			// In the fromChild case the current node was already tested when going
			// down, and does not have to bce re - tested.The next node to traverse
			// is either current’s sibling f arChild(if current is nearChild),
			// or its parent(if current was farChild).
			//
			case FROM_CHILD:
			{
				if (current == root) {
					isIterating = false;
				} else if (current == getNearSibling(current)) {
					current = getFarSibling(current);
					state = FROM_SIBLING;

				} else {
					current = getParent(current);
					state = FROM_CHILD;
				}
				break;
			}
			// 2. From sibling
			// In the fromSibling case, we know that we are entering farChild (it
			// cannot be reached in any other way), and that we are traversing this
			// node for the first time(i.e.a box test has to be done).If the node
			// is missed, we back - track to its parent; otherwise, the current node
			// has to be processed : if it is a leaf node, we intersect its primitives
			// against the ray, and proceed to parent. Otherwise(i.e. if the node
			// was hit but is not a leaf), we enter current’s subtree by performing
			// a fromParent step to current’s first child.
			case FROM_SIBLING:
			{
				if (bvhNodes[current].geomId > -1) {
					// Leaf node
					isx.t = 1;
					return isx;
					
					// Reconstruct triangle
					Triangle tri;
					buildTriangle(bvhNodes[current].geomId, tri);
					t = triangleIntersect(tri, ray, tmp_normal, tmp_hitPoint);
					if ((t > EPSILON) && (t < tMin))
					{
						tMin = t;
						isx.t = t;
						isx.hitPoint = tmp_hitPoint;
						isx.hitNormal = tmp_normal;
						isx.objectID = tri.materialId;
					}

					current = getParent(current);
					state = FROM_CHILD;

				} else {
					// When this isn't a leaf node, check bbox intersection
					t = aabbIntersect(ray, current);
					if ( (t < MAXLEN) && (t > EPSILON) ) {
						// Hit, enter its subtree (near child)
						int nearChild = getNearChild(current);
						int farChild = getFarChild(current);

						if (nearChild != -1) {
							current = nearChild;
							state = FROM_PARENT;
						} else {
							current = farChild;
							state = FROM_SIBLING;
						}

					} else {
						// Miss, go backup to parent
						if (current == root) {
							// Current has reached root
							isIterating = false;
						} else {
							current = getParent(current);
							state = FROM_CHILD;
						}
					}
				}
				break;
			}
			// 3. From parent
			// Finally, in the fromParent case, we know that we are entering
			// nearChild and we do exactly the same as in the previous case,
			// except that every time we would have gone to parent we go to
			// farChild child.
			case FROM_PARENT: {
				if (bvhNodes[current].geomId > -1) {
					// Leaf node
					
					// Reconstruct triangle
					Triangle tri;
					buildTriangle(bvhNodes[current].geomId, tri);
					t = triangleIntersect(tri, ray, tmp_normal, tmp_hitPoint);
					if ((t > EPSILON) && (t < tMin))
					{
						tMin = t;
						isx.t = t;
						isx.hitPoint = tmp_hitPoint;
						isx.hitNormal = tmp_normal;
						isx.objectID = tri.materialId;
					}

					if (current == root) {
						// Current has reached root
						isIterating = false;
					} else {
						current = getFarSibling(current);
						state = FROM_SIBLING;
					}

				} else {
					// Not a leaf node, check internal node intersection
					t = aabbIntersect(ray, current);
					if ( (t < MAXLEN) && t > EPSILON) {

						// Hit, enter its subtree (near child)
						int nearChild = getNearChild(current);
						int farChild = getFarChild(current);

						if (nearChild != -1) {
							current = nearChild;
							state = FROM_PARENT;
						} else {
							current = farChild;
							state = FROM_SIBLING;
						}


					} else {

						// Miss, go to far sibling
						if (current == root) {
							isIterating = false;
						} else {

							current = getFarSibling(current);
							state = FROM_SIBLING;
						}
					}
				}
				break;
			}
			default:
			break;
		}
	}
	return isx;
}

// ==================================
// COMPUTE INTERSECTION
// ==================================

Intersection getIsx(
	inout PathSegment path
	)
{
	float tMin = MAXLEN;
	vec3 normal;
	vec3 hitPoint;
	int objectID = -1;
	int materialID = 0;
	Intersection intersection;

	for (int i = 0; i < indicesAndMaterialID.length(); ++i) {
		
		if (indicesAndMaterialID[i].w == path.objectId) {
			// Skip self
			continue;
		}

		 //Reconstruct triangle
		Triangle tri;
		buildTriangle(i, tri);

		vec3 tmp_normal;
		vec3 tmp_hitPoint;
		float tTri = triangleIntersect(tri, path.ray, tmp_normal, tmp_hitPoint);
		if ((tTri > EPSILON) && (tTri < tMin))
		{
			objectID = tri.materialId;
			tMin = tTri;
			normal = tmp_normal;
			hitPoint = tmp_hitPoint;
			materialID = tri.materialId;
			path.objectId = objectID;
		}
	}

	if (objectID == -1)
	{
		intersection.t = -1.0;
	} else {
		intersection.t = tMin;
		intersection.materialId = materialID;
		intersection.hitNormal = normal;
		intersection.hitPoint = hitPoint;
		intersection.objectID = objectID;
	}

	return intersection;
}

// ==================================
// COMPUTE SHADOWS
// ==================================

float calcShadow(in Ray feeler, in int objectId, in float t)
{
	for (int i = 0; i < indicesAndMaterialID.length(); ++i)
	{	      
		// Reconstruct triangle
		Triangle tri;
		buildTriangle(i, tri);

		vec3 tmp_normal;
		vec3 tmp_hitPoint;
		float tTri = triangleIntersect(tri, feeler, tmp_normal, tmp_hitPoint);
		if (tTri > EPSILON && tTri < t)
		{
			return 0.5;
		}
	}
	return 1.0;
} 

// ==================================
// SHADING
// ==================================

float lightDiffuse(vec3 normal, vec3 lightDir) 
{
	// Use half lambert here to pop up the color
	return dot(normal, lightDir) * 0.5 + 0.5;
}

// Blinn-Phong
float lightSpecular(vec3 cameraPosition, vec3 normal, vec3 lightDir, float specularFactor)
{
	vec3 viewVec = normalize(cameraPosition);
	vec3 halfVec = normalize(lightDir + viewVec);
	return pow(clamp(dot(normal, halfVec), 0.0, 1.0), specularFactor);
}

// From http://filmicgames.com/archives/75
vec3 Uncharted2Tonemap( vec3 x )
{
	float A = 0.15;
	float B = 0.50;
	float C = 0.10;
	float D = 0.20;
	float E = 0.02;
	float F = 0.30;
	return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}

// https://learnopengl.com/#!PBR/Lighting

float DistributionGGX(vec3 N, vec3 H, float roughness) {
	float a = roughness * roughness;
	float a2 = a * a;
	float NdotH = max(dot(N, H), 0.0);
	float NdotH2 = NdotH*NdotH;

	float nom = a2;
	float denom = (NdotH2 * (a2 - 1.0) + 1.0);
	denom *= PI * denom * denom;

	return nom / denom;
}

float GeometrySchlickGGX(float NdotV, float roughness) {
	float r = (roughness + 1.0);
	float k = (r*r) / 8.0;
	float nom = NdotV;
	float denom = NdotV * (1.0 - k) + k;

	return nom / denom;
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
{
	float NdotV = max(dot(N, V), 0.0);
	float NdotL = max(dot(N, L), 0.0);
	float ggx2 = GeometrySchlickGGX(NdotV, roughness);
	float ggx1 = GeometrySchlickGGX(NdotL, roughness);

	return ggx1 * ggx2;
}

vec3 FresnelSchlick(float cosTheta, vec3 F0)
{
	return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

// Environment BRDF approximation from https://www.unrealengine.com/blog/physically-based-shading-on-mobile
vec3 EnvBRDFApprox(vec3 specularColor, float roughness, float NdotV)
{
	vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
	vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
	vec4 r = roughness * c0 + c1;
	float a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;
	vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;
	return specularColor * AB.x + AB.y;
}

void shade(
	in Intersection isx,
	inout PathSegment path
	)
{
	// Terminate if there's no more bounces
	Material material = materials[isx.materialId];

	path.remainingBounces = 0;
	int MAX_LIGHTS = 10;

	vec3 N = normalize(isx.hitNormal);
	vec3 V = normalize(vec3(ubo.cameraPosition) - isx.hitPoint);
	vec3 R = reflect(-V, N);
	vec3 albedo = path.color;
	vec3 F0 = vec3(0.04);
	F0 = mix(F0, albedo, metallic);

	vec3 Lo = vec3(0.0);
	for (int i = 0; i < MAX_LIGHTS; ++i) {
					
		if (i >= ubo.lightCount) {
			break;
		}

		float dist = length(vec3(ubo.lights[i].position) - isx.hitPoint);
		if (dist >= ubo.lights[i].radius) {
			continue;
		}

		vec3 L = normalize(vec3(ubo.lights[i].position) - isx.hitPoint);
		vec3 H = normalize(V + L);
		float attenuation	= 1.0 / (dist * dist);
		vec3 radiance		= ubo.lights[i].color * attenuation;

		vec3 F = FresnelSchlick(max(dot(H, V), 0.0), F0);

		float NDF = DistributionGGX(N, H, roughness);
		float G = GeometrySmith(N, V, L, roughness);

		float NdotL = max(dot(N, L), 0.0);
		vec3 nom = NDF * G * F;
		float denom = 4.0 * max(dot(N, V), 0.0) * NdotL + 0.001;
		vec3 specular = nom / denom;

		vec3 kS = F;
		vec3 kD = vec3(1.0) - kS;
		kD *= 1.0 - metallic;

		//// Light feeler test
		//Ray feeler;
		//feeler.origin = isx.hitPoint + 0.002 * L;
		//feeler.direction = L;
		//feeler.inv_direction = vec3(1.0/feeler.direction.x, 1.0/feeler.direction.y, 1.0/feeler.direction.z);
		//feeler.sign[0] = (feeler.inv_direction.x < 0) ? 1 : 0;
		//feeler.sign[1] = (feeler.inv_direction.y < 0) ? 1 : 0;
		//feeler.sign[2] = (feeler.inv_direction.z < 0) ? 1 : 0;
			
		//float shadow = 1;//calcShadow(feeler, isx.materialId, dist); 
		//Intersection shadowIsx = calcShadowBVH(feeler, 0);
		//if (shadowIsx.t > 0) {
		//	shadow = 0.1;
		//}

		//vec3 diffuseColor = material.diffuse.rgb;
		//float atten = 0.1;
		//if (shadow > 0.5) {
		//	atten = ubo.lights[i].radius / (pow(dist, 2.0) + 1.0);		
		//	float diffuse = lightDiffuse(isx.hitNormal, L);
		//	diffuseColor *= diffuse;
		//}

		//path.color *= shadow;
		// Cubemap sampling
		ivec2 cubeDim = textureSize(radianceMap, 0);
		int numMipLevels = int(log2(max(cubeDim.s, cubeDim.y)));
		float mipLevel = numMipLevels - 1.0 + log2(roughness);
		vec3 radianceSample = pow(textureLod(radianceMap, R, mipLevel).rgb, vec3(2.2));
		vec3 irradianceSample = pow(texture(irradianceMap, N).rgb, vec3(2.2));

		vec3 reflection = EnvBRDFApprox(specular, pow(roughness, 1.0f), clamp(dot(N, V), 0.0, 1.0));
	

		// Combine specular IBL and BRDF
		//albedo = albedo * irradianceSample;
		//specular = radianceSample * reflection;

		Lo += (kD * albedo / PI + specular) * radiance * NdotL;


	}

	vec3 ambient = vec3(0.03) * albedo;
	path.color = ambient + Lo;
	path.color = Uncharted2Tonemap(path.color * 1.0);
	path.color = path.color / Uncharted2Tonemap(vec3(11.2));
	path.color = pow(path.color, vec3(1.0/2.2));
}

vec2 envMapEquirect(vec3 normal) 
{
	float phi = acos(-normal.y);
	float theta = atan(-1.0 * normal.x, normal.z) + PI;
	return vec2(theta / TWO_PI, phi / PI);
}

void main()
{
	ivec2 dim = imageSize(resultImage);
	vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;
	
	vec3 position = texture(positionsImage, uv).rgb;
	vec3 normal = texture(normalsImage, uv).rgb;
	
	// Here, materialId was normalized and packed as the fourth value
	float materialIdNormalized = texture(positionsImage, uv).w;
	int materialId = int(materialIdNormalized * float(ubo.materialCount));

	PathSegment path;
	path.remainingBounces = TRACEDEPTH;
	path.ray.direction = normalize(vec3(ubo.cameraPosition) - position);
	path.ray.origin = position + 0.01 * path.ray.direction;
	path.objectId = materialId; // Use material ID as object ID
	path.bounces = 0;
	path.color = texture(albedo, uv).rgb;

	if (normal == vec3(0, 0, 0)) {
		imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(path.color, 0.0));
		return;
	}

	Intersection isx;
	isx.hitPoint = position;
	isx.hitNormal = normal;
	isx.materialId = materialId;
	isx.t = 1;

	//for (int i = 0; i < spheres.length(); ++i) {
	//	float t = sphereIntersect(path.ray, i);
	//	if (t > 0) {
	//		isx.hitPoint = path.ray.origin + t * path.ray.direction;
	//	}
	//}

	shade(isx, path);

	// Trace ray
	while(path.remainingBounces > 0) {		
		isx = getIsx(path);
		shade(isx, path);
	}

	// Color by the number of bounces
	if (ubo.isColorByRayBounces) {
		float val = path.bounces / TRACEDEPTH;
		imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(val, val, val, 1.0));
	} else {
		imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(path.color, 1.0));
	}	
}