// Shader is looseley based on the ray tracing coding session by Inigo Quilez (www.iquilezles.org)
// Based on Sascha Willems example: https://github.com/SaschaWillems/Vulkan/tree/master/data/shaders/raytracing

#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

#define PI 3.1415926535897932384626422832795028841971
#define TWO_PI 6.2831853071795864769252867665590057683943
#define SQRT_OF_ONE_THIRD 0.5773502691896257645091487805019574556476
#define EPSILON 0.0001
#define MAXLEN 1000.0
#define TRACEDEPTH 2
#define GROUND_MESH_IDX 2

// ===== STRUCT DEFINITION ===== //
struct Light {
	vec4 position;
	vec3 color;
	float radius;
};

struct Material
{
	vec4 diffuse;
	vec4 ambient;
	vec4 emission;
	vec4 specular;
	float shininess;
	float refracti;
};

struct Triangle
{
	int materialId;

	vec3 vert0;
	vec3 vert1;
	vec3 vert2;

	vec3 norm0;
	vec3 norm1;
	vec3 norm2;
};

struct BVHNodePacked
{
	int id;
	int parent;
	int geomId;
	vec4 bounds[2];
};

struct Ray
{
	vec3 origin;
	vec3 direction;
    
    // The following variables are pre-computed for faster Ray-AABB intersection tests.
    vec3 inv_direction;
    int sign[3];
};

struct PathSegment {
	Ray ray;
	vec3 color;
	int remainingBounces;
	int objectId;
	int bounces;
};

struct Intersection {
	vec3 hitNormal;
	float t;
	vec3 hitPoint;
	int materialId;
	int objectID;
};

// ===== LAYOUT AND BINDING ===== //

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0) uniform sampler2D positionsImage;
layout (binding = 1) uniform sampler2D normalsImage;
layout (binding = 2, rgba8) uniform writeonly image2D resultImage;

layout (std140, binding = 3) buffer TriangleIndices
{
	ivec4 indicesAndMaterialID[ ];
};

layout (std140, binding = 4) buffer TrianglePositions
{
	vec4 positions[ ];
};

layout (std140, binding = 5) buffer TriangleNormals
{
	vec4 normals[ ];
};

layout (std140, binding = 6) uniform UBO 
{
	vec4 cameraPosition;
	Light lights[6];
	int lightCount;
	int materialCount;

	// Toggle flags 
	bool isBVH;
	bool isShadows;
	bool isTransparency;
	bool isReflection;
	bool isColorByRayBounces;
} ubo;


layout (std140, binding = 7) uniform Materials
{
	Material materials[10];
};

layout (std140, binding = 8) buffer BVHNodes
{
    BVHNodePacked bvhNodes[ ];
};

layout (binding = 9) uniform sampler2D albedo;


// ===== REFLECT FUNCTION ===== //

void reflectRay(inout vec3 rayD, in vec3 normal)
{
	rayD = rayD + 2.0 * -dot(normal, rayD) * normal;
}

// Lighting =========================================================

float lightDiffuse(vec3 normal, vec3 lightDir) 
{
	// Use half lambert here to pop up the color
	return dot(normal, lightDir) * 0.5 + 0.5;
}

float lightSpecular(vec3 cameraPosition, vec3 normal, vec3 lightDir, float specularFactor)
{
	vec3 viewVec = normalize(cameraPosition);
	vec3 halfVec = normalize(lightDir + viewVec);
	return pow(clamp(dot(normal, halfVec), 0.0, 1.0), specularFactor);
}

// Intersection helper ===========================================================

// From StackOverflow http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl
float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 getPointOnRay(Ray r, float t) {
    return r.origin + (t - .0001f) * normalize(r.direction);
}

// Triangle ===========================================================

void buildTriangle(int i, inout Triangle tri) {
	
	tri.materialId = indicesAndMaterialID[i].w;
	tri.vert0 = vec3(positions[indicesAndMaterialID[i].x]);
	tri.vert1 = vec3(positions[indicesAndMaterialID[i].y]);
	tri.vert2 = vec3(positions[indicesAndMaterialID[i].z]);
	tri.norm0 = vec3(normals[indicesAndMaterialID[i].x]);
	tri.norm1 = vec3(normals[indicesAndMaterialID[i].y]);
	tri.norm2 = vec3(normals[indicesAndMaterialID[i].z]);
	tri.vert0 = vec3(5, 15, -5);
	tri.vert1 = vec3(15, 15, 10);
	tri.vert2 = vec3(-5, 15, 5);
}

float triangleIntersect(
	in Triangle tri, 
	in Ray r,
	out vec3 normal,
	out vec3 hitPoint
	) 
{
	// Compute fast intersection using Muller and Trumbore, this skips computing the plane's equation.
	// See https://www.cs.virginia.edu/~gfx/Courses/2003/ImageSynthesis/papers/Acceleration/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf

	float t = -1.0;
	
	// Find the edges that share vertice 0
	vec3 edge1 = tri.vert1 - tri.vert0;
	vec3 edge2 = tri.vert2 - tri.vert0;

	// Being computing determinante. Store pvec for recomputation
	vec3 pvec = cross(r.direction, edge2);
	// If determinant is 0, ray lies in plane of triangle
	float det = dot(pvec, edge1);
	if (abs(det) < EPSILON) {
		return -1;
	}
	float inv_det = 1.0 / det;
	vec3 tvec = r.origin - tri.vert0;

	// u, v are the barycentric coordinates of the intersection point in the triangle
	// t is the distance between the ray's origin and the point of intersection
	float u, v;

	// Compute u
	u = dot(pvec, tvec) * inv_det;
	if (u < 0.0 || u > 1.0) {
		return -1;
	}

	// Compute v
	vec3 qvec = cross(tvec, edge1);
	v = dot(r.direction, qvec) * inv_det;
	if (v < 0.0 || (u + v) > 1.0) {
		return -1;
	}

	// Compute t
	t = dot(edge2, qvec) * inv_det;

	hitPoint = getPointOnRay(r, t);
	normal = normalize(tri.norm0 * (1 - u - v) + tri.norm1 * u + tri.norm2 * v);

	return t;
}

// Sphere ==========================================================
/*
float sphereIntersect(in Ray ray, in int sphereIdx)
{
    vec3 spherePos  = sphere[sphereIdx].xyz;
    float sphereRad = sphere[sphereIdx].w;
    
	vec3 oc = ray.origin - spherePos;
	float b = 2.0 * dot(oc, ray.direction);
	float c = dot(oc, oc) - sphereRad * sphereRad;
	float h = b*b - 4.0*c;
	if (h < 0.0) 
	{
		return -1.0;
	}
	float t = (-b - sqrt(h)) / 2.0;

	return t;
}
*/

// Aabb ===========================================================

float aabbIntersect(in Ray r, in BVHNodePacked aabb)
{
    float tmin  = (aabb.bounds[r.sign[0]].x      - r.origin.x) * r.inv_direction.x;
    float tmax  = (aabb.bounds[1-r.sign[0]].x    - r.origin.x) * r.inv_direction.x;
    float tymin = (aabb.bounds[r.sign[1]].y      - r.origin.y) * r.inv_direction.y;
    float tymax = (aabb.bounds[1-r.sign[1]].y    - r.origin.y) * r.inv_direction.y;
    
    if ( (tmin > tymax) || (tymin > tmax) )
        return MAXLEN;
    if (tymin > tmin)
        tmin = tymin;
    if (tymax < tmax)
        tmax = tymax;
        
    float tzmin = (aabb.bounds[r.sign[2]].z     - r.origin.z) * r.inv_direction.z;
    float tzmax = (aabb.bounds[1-r.sign[2]].z   - r.origin.z) * r.inv_direction.z;
    
    if ( (tmin > tzmax) || (tzmin > tmax) )
        return MAXLEN;
   if (tzmin > tmin)
        tmin = tzmin;
    if (tzmax < tmax)
        tmax = tzmax;
        
    if ( (tmin < MAXLEN) && (tmax > EPSILON) );
        return 1.0f;
}

// Intersection ===========================================================

/*
* Iterative stack-less BVH traversal using state logic and pointers to nodes.
* \ref https://graphics.cg.uni-saarland.de/fileadmin/cguds/papers/2011/hapala_sccg2011/hapala_sccg2011.pdf
*/
// void traverseBVH(
//	int depth
//	, int num_paths
//	, PathSegment * pathSegments
//	, int num_bvhNodes
//	, BVHNodeDev* bvhNodes
//	, int rootIdx
//	, int geoms_size
//	, Geom * geoms
//	, ShadeableIntersection * intersections
//	)
//{
//	int path_index = blockIdx.x * blockDim.x + threadIdx.x;

//	if (path_index < num_paths)
//	{
//		PathSegment pathSegment = pathSegments[path_index];
//		float t;
//		glm::vec3 intersect_point;
//		glm::vec3 normal;
//		float t_min = FLT_MAX;

//		glm::vec3 tmp_intersect;
//		glm::vec3 tmp_normal;
//		Geom* hit_geom = nullptr;

//		BVHNodeDev current = bvhNodes[rootIdx];
//		EBVHTransition transition = EBVHTransition::FromParent;

//		bool isIterating = true;
//		while (isIterating) {
//			// States (reproduced here from Stack-less BVH Traversal paper [Hapala1 el at. 2011])
//			// Link: https://graphics.cg.uni-saarland.de/fileadmin/cguds/papers/2011/hapala_sccg2011/hapala_sccg2011.pdf
//			switch (transition) {

//				// 1. From child
//				// In the fromChild case the current node was already tested when going
//				// down, and does not have to bce re - tested.The next node to traverse
//				// is either current’s sibling f arChild(if current is nearChild),
//				// or its parent(if current was farChild).
//				//
//			case EBVHTransition::FromChild:
//				if (current.idx == rootIdx) {
//					// Current has reached root
//					isIterating = false;
//				}
//				else if (current.idx == bvhNodes[current.parentIdx].nearChildIdx) {
//					// Current is near child, so transition to far child
//					current = bvhNodes[bvhNodes[current.parentIdx].farChildIdx];
//					transition = EBVHTransition::FromSibling;
//				}
//				else {
//					// Current is far child, go back to parent
//					current = bvhNodes[current.parentIdx];
//					transition = EBVHTransition::FromChild;
//				}
//				break;

//				// 2. From sibling
//				// In the fromSibling case, we know that we are entering farChild (it
//				// cannot be reached in any other way), and that we are traversing this
//				// node for the first time(i.e.a box test has to be done).If the node
//				// is missed, we back - track to its parent; otherwise, the current node
//				// has to be processed : if it is a leaf node, we intersect its primitives
//				// against the ray, and proceed to parent. Otherwise(i.e. if the node
//				// was hit but is not a leaf), we enter current’s subtree by performing
//				// a fromParent step to current’s first child.

//			case EBVHTransition::FromSibling:

//				if (current.geomIdx != -1) {
//					// Leaf node
//					t = computeIntersection(pathSegment, geoms[current.geomIdx], tmp_intersect, tmp_normal);
//					// Compute the minimum t from the intersection tests to determine what
//					// scene geometry object was hit first.
//					if (t > 0.0f && t_min > t)
//					{
//						t_min = t;
//						intersect_point = tmp_intersect;
//						normal = tmp_normal;
//						hit_geom = &(geoms[current.geomIdx]);
//					}

//					current = bvhNodes[current.parentIdx];
//					transition = EBVHTransition::FromChild;
//				}
//				else {
//					// When this isn't a leaf node, check bbox intersection
//					bool hit = bboxIntersectionTest(current.bboxGeom, pathSegments[path_index].ray);
//					if (!hit) {
//						// Missed, go back up to parent

//						if (current.idx == rootIdx) {
//							// Current has reached root
//							isIterating = false;
//						} else {
//							current = bvhNodes[current.parentIdx];
//							transition = EBVHTransition::FromChild;
//						}
//					}
//					else {
//						// Hit, enter its subtree (near child)
//						current = bvhNodes[current.nearChildIdx];
//						transition = EBVHTransition::FromParent;
//					}
//				}
//				break;

//				// 3. From parent
//				// Finally, in the fromParent case, we know that we are entering
//				// nearChild and we do exactly the same as in the previous case,
//				// except that every time we would have gone to parent we go to
//				// farChild child.

//			case EBVHTransition::FromParent:
//				if (current.geomIdx != -1) {
//					// Leaf node
//					t = computeIntersection(pathSegment, geoms[current.geomIdx], tmp_intersect, tmp_normal);
//					// Compute the minimum t from the intersection tests to determine what
//					// scene geometry object was hit first.
//					if (t > 0.0f && t_min > t)
//					{
//						t_min = t;
//						intersect_point = tmp_intersect;
//						normal = tmp_normal;
//						hit_geom = &(geoms[current.geomIdx]);
//					}

//					if (current.idx == rootIdx) {
//						// Current has reached root
//						isIterating = false;
//					} else {
//						// Go to far sibling
//						current = bvhNodes[bvhNodes[current.parentIdx].farChildIdx];
//						transition = EBVHTransition::FromSibling;
//					}
//				}
//				else {
//					// When this isn't a leaf node, check bbox intersection
//					bool hit = bboxIntersectionTest(current.bboxGeom, pathSegments[path_index].ray);
//					if (!hit) {
//						// Missed, go to far sibling
//						if (current.idx == rootIdx) {
//							// Current has reached root
//							isIterating = false;
//						} else {
//							current = bvhNodes[bvhNodes[current.parentIdx].farChildIdx];
//							transition = EBVHTransition::FromSibling;
//						}
//					}
//					else {
//						// Hit, enter its subtree
//						current = bvhNodes[current.nearChildIdx];
//						transition = EBVHTransition::FromParent;
//					}
//				}
//				break;
			
//			default:
//				// *N.B*: Should never reach here
//				assert(false);
//				break;
//			}
//		}
		
//		if (hit_geom == nullptr)
//		{
//			intersections[path_index].t = -1.0f;
//		}
//		else
//		{
//			//The ray hits something
//			intersections[path_index].t = t_min;
//			intersections[path_index].materialId = hit_geom->materialid;
//			intersections[path_index].surfaceNormal = normal;
//			intersections[path_index].intersect_point = intersect_point;
//		}
//	}
//}


Intersection computeIntersections(
	inout PathSegment path
	)
{
	float tMin = MAXLEN;
	vec3 normal;
	vec3 hitPoint;
	int objectID = -1;
	int materialID = 0;
	Intersection intersection;


	// Triangles

	for (int i = 0; i < indicesAndMaterialID.length(); ++i) {
		
		if (indicesAndMaterialID[i].w == path.objectId) {
			// Skip self
			continue;
		}

		 //Reconstruct triangle
		Triangle tri;
		buildTriangle(i, tri);

		vec3 tmp_normal;
		vec3 tmp_hitPoint;
		float tTri = triangleIntersect(tri, path.ray, tmp_normal, tmp_hitPoint);
		if ((tTri > EPSILON) && (tTri < tMin))
		{
			objectID = tri.materialId;
			tMin = tTri;
			normal = tmp_normal;
			hitPoint = tmp_hitPoint;
			materialID = tri.materialId;
			path.objectId = objectID;
		}
	}

	if (objectID == -1)
	{
		intersection.t = -1.0;
	} else {
		intersection.t = tMin;
		intersection.materialId = materialID;
		intersection.hitNormal = normal;
		intersection.hitPoint = hitPoint;
		intersection.objectID = objectID;
	}

	return intersection;
}

float calcShadow(in Ray feeler, in int objectId, in float t)
{
	for (int i = 0; i < indicesAndMaterialID.length(); ++i)
	{	
		//if (indicesAndMaterialID[i].w == objectId)
		//{
		//	// Skip self
		//	continue;
		//}
        
		// Reconstruct triangle
		Triangle tri;
		buildTriangle(i, tri);

		vec3 tmp_normal;
		vec3 tmp_hitPoint;
		float tTri = triangleIntersect(tri, feeler, tmp_normal, tmp_hitPoint);
		if (tTri > EPSILON && tTri < t)
		{
			return 0.5;
		}
	}
	return 1.0;
} 

// ===== MATH HELPERS ===== //
float costheta(vec3 i, vec3 n) {
	return dot(i, n);
}

float sintheta2(vec3 i, vec3 n) {
	return max(0, 1 - costheta(i, n) * costheta(i, n));
}

// ===== MATERIALS ===== //

// From pbrt, computing Fresnel reflection formula for dielectric materials and 
// circularly polarized light.
float frDiel(float cosi, float cost, float etai, float etat) {
	float Rparl = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));
	float Rperp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));
	return (Rparl * Rparl + Rperp * Rperp) / 2.0;
}

void shadeMaterial(
	in Intersection intersect,
	inout PathSegment path
	)
{
	if (intersect.t < 0.0) {
		path.remainingBounces = 0;
		return;
	}

	Material material = materials[intersect.materialId];

	path.remainingBounces = 0;

	for (int i = 0; i < 10; ++i) {
					
		if (i >= ubo.lightCount) {
			break;
		}

		vec3 lightVec = normalize(vec3(ubo.lights[i].position) - intersect.hitPoint);
		float dist = length(vec3(ubo.lights[i].position) - intersect.hitPoint);
		
		//if (dist >= ubo.lights[i].radius) {
		//	continue;
		//}

		// Light feeler test
		Ray feeler;
		feeler.origin = intersect.hitPoint + 0.001 * lightVec;
		feeler.direction = lightVec;
		//feeler.origin = vec3(0, 0, 0);
		feeler.direction = vec3(0, 1, 0);
		feeler.inv_direction = vec3(1/feeler.direction.x, 1/feeler.direction.y, 1/feeler.direction.z);
		feeler.sign[0] = (feeler.inv_direction.x < 0) ? 1 : 0;
		feeler.sign[1] = (feeler.inv_direction.y < 0) ? 1 : 0;
		feeler.sign[2] = (feeler.inv_direction.z < 0) ? 1 : 0;
			
		float shadow = calcShadow(feeler, intersect.materialId, dist); 
		vec3 diffuseColor = material.diffuse.rgb;
		float atten = 0.1;
		if (shadow > 0.5) {
			// Attenuation
			atten = ubo.lights[i].radius / (pow(dist, 2.0) + 1.0);
		
			// Diffuse
			float diffuse = lightDiffuse(intersect.hitNormal, lightVec);
			diffuseColor = diffuse * diffuseColor;
		}
	
		
		//// Specular
		//float specular = lightSpecular(vec3(ubo.cameraPosition), intersect.hitNormal, lightVec, 5);
		//vec3 specularColor = specular * vec3(material.specular); 
		
		path.color += diffuseColor * ubo.lights[i].color * atten;
		path.color *= shadow;
	}
}

// Generate ray ========================

void main()
{
	ivec2 dim = imageSize(resultImage);
	vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;
	
	// Extract parameters from textures
	vec3 position = texture(positionsImage, uv).rgb;
	vec3 normal = texture(normalsImage, uv).rgb;
	
	// Here, materialId was normalized and packed as the fourth value
	float materialIdNormalized = texture(positionsImage, uv).w;
	int materialId = int(materialIdNormalized * float(ubo.materialCount));

	PathSegment path;
	path.remainingBounces = TRACEDEPTH;
	path.ray.direction = normalize(vec3(ubo.cameraPosition) - position);
	path.ray.origin = position + 0.01 * path.ray.direction;
	path.objectId = materialId; // Use material ID as object ID
	path.bounces = 0;
	path.color = texture(albedo, uv).rgb * materials[materialId].diffuse.rgb;

	if (normal == vec3(0, 0, 0)) {
		// Nothing to compute here
		// Shade background
		float t = 0.5 * path.ray.direction.y + 1.0;
		vec3 skyColor = (1.0f - t) * vec3(1, 1, 1) + t * vec3(0.5, 0.7, 1.0);
		imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(skyColor, 1.0));
		return;
	}

	Intersection intersection;
	intersection.hitPoint = position;
	intersection.hitNormal = normal;
	intersection.materialId = materialId;
	intersection.t = 1;

	// Shade and reflect
	shadeMaterial(intersection, path);

	// Trace ray
	//while(path.remainingBounces > 0) {
		
	//	intersection = computeIntersections(path);
	//	shadeMaterial(intersection, path);
	//}

	// Color by the number of bounces
	if (ubo.isColorByRayBounces) {
		float val = path.bounces / TRACEDEPTH;
		imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(val, val, val, 1.0));
	} else {
		imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(path.color, 1.0));
		//vec3 corlor = texture(albedo, uv).rgb;
		//imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(corlor, 1.0));
	}	
}